{"version":3,"file":"app.js","sources":["../node_modules/endorphin/runtime/runtime.es.js","../src/colors.js","../src/colors.html","../src/app.js"],"sourcesContent":["/**\n * Shorthand for `elem.appendChild()` for better minification\n */\nfunction appendChild(element, node) {\n    return element.appendChild(node);\n}\n/**\n * Creates element with given tag name\n * @param cssScope Scope for CSS isolation\n */\nfunction elem(tagName, cssScope) {\n    return isolateElement(document.createElement(tagName), cssScope);\n}\n/**\n * Creates element with given tag name under `ns` namespace\n * @param cssScope Scope for CSS isolation\n */\nfunction elemNS(tagName, ns, cssScope) {\n    return isolateElement(document.createElementNS(ns, tagName), cssScope);\n}\n/**\n * Creates element with given tag name and text\n * @param cssScope Scope for CSS isolation\n */\nfunction elemWithText(tagName, value, cssScope) {\n    const el = elem(tagName, cssScope);\n    el.appendChild(textNode(value));\n    return el;\n}\n/**\n * Creates element with given tag name under `ns` namespace and text\n * @param cssScope Scope for CSS isolation\n */\nfunction elemNSWithText(tagName, ns, value, cssScope) {\n    const el = elemNS(tagName, ns, cssScope);\n    el.appendChild(textNode(value));\n    return el;\n}\n/**\n * Creates text node with given value\n */\nfunction text(value) {\n    const node = textNode(value);\n    node.$value = value;\n    return node;\n}\n/**\n * Creates text node with given value\n */\nfunction textNode(value) {\n    return document.createTextNode(value != null ? value : '');\n}\n/**\n * Updates given text node value, if required\n * @returns Returns `1` if text was updated, `0` otherwise\n */\nfunction updateText(node, value) {\n    if (value !== node.$value) {\n        // node.nodeValue = textValue(value);\n        node.nodeValue = value != null ? value : '';\n        node.$value = value;\n        return 1;\n    }\n    return 0;\n}\n/**\n * Isolates given element with CSS scope\n */\nfunction isolateElement(el, cssScope) {\n    cssScope && el.setAttribute(cssScope, '');\n    return el;\n}\n/**\n * @returns Inserted item\n */\nfunction domInsert(node, parent, anchor) {\n    return anchor\n        ? parent.insertBefore(node, anchor)\n        : parent.appendChild(node);\n}\n/**\n * Removes given DOM node from its tree\n * @param {Node} node\n */\nfunction domRemove(node) {\n    const { parentNode } = node;\n    parentNode && parentNode.removeChild(node);\n}\n/**\n * Returns textual representation of given `value` object\n */\n// function textValue(value: any): string {\n// \treturn value != null ? value : '';\n// }\n\nconst animatingKey = '$$animating';\n/**\n * Creates fast object\n */\nfunction obj(proto = null) {\n    return Object.create(proto);\n}\n/**\n * Check if given value id defined, e.g. not `null`, `undefined` or `NaN`\n */\nfunction isDefined(value) {\n    return value != null && value === value;\n}\n/**\n * Returns properties from `next` which were changed since `prev` state.\n * Returns `null` if there are no changes\n */\nfunction changed(next, prev, prefix = '') {\n    const result = obj();\n    let dirty = false;\n    // Check if data was actually changed\n    for (const p in next) {\n        if (prev[p] !== next[p]) {\n            dirty = true;\n            result[prefix ? prefix + p : p] = {\n                prev: prev[p],\n                current: next[p]\n            };\n        }\n    }\n    return dirty ? result : null;\n}\n// tslint:disable-next-line:only-arrow-functions\nconst assign = Object.assign || function (target) {\n    for (let i = 1, source; i < arguments.length; i++) {\n        source = arguments[i];\n        for (const p in source) {\n            if (source.hasOwnProperty(p)) {\n                target[p] = source[p];\n            }\n        }\n    }\n    return target;\n};\n/**\n * Returns property descriptors from given object\n */\n// tslint:disable-next-line:only-arrow-functions\nconst getObjectDescriptors = Object['getOwnPropertyDescriptors'] || function (source) {\n    const descriptors = obj();\n    const props = Object.getOwnPropertyNames(source);\n    for (let i = 0, prop, descriptor; i < props.length; i++) {\n        prop = props[i];\n        descriptor = Object.getOwnPropertyDescriptor(source, prop);\n        if (descriptor != null) {\n            descriptors[prop] = descriptor;\n        }\n    }\n    return descriptors;\n};\n/**\n * Represents given attribute value in element\n * @param {Element} elem\n * @param {string} name\n * @param {*} value\n */\nfunction representAttributeValue(elem, name, value) {\n    const type = typeof (value);\n    if (type === 'boolean') {\n        value = value ? '' : null;\n    }\n    else if (type === 'function') {\n        value = '𝑓';\n    }\n    else if (Array.isArray(value)) {\n        value = '[]';\n    }\n    else if (isDefined(value) && type === 'object') {\n        value = '{}';\n    }\n    isDefined(value) ? elem.setAttribute(name, value) : elem.removeAttribute(name);\n}\nfunction safeCall(fn, arg1, arg2) {\n    try {\n        return fn && fn(arg1, arg2);\n    }\n    catch (err) {\n        // tslint:disable-next-line:no-console\n        console.error(err);\n    }\n}\nfunction captureError(host, fn, arg1, arg2) {\n    try {\n        return fn && fn(arg1, arg2);\n    }\n    catch (error) {\n        runtimeError(host, error);\n        // tslint:disable-next-line:no-console\n        console.error(error);\n    }\n}\nfunction runtimeError(host, error) {\n    if (typeof CustomEvent !== 'undefined') {\n        host.dispatchEvent(new CustomEvent('runtime-error', {\n            bubbles: true,\n            cancelable: true,\n            detail: { error, host }\n        }));\n    }\n    else {\n        throw error;\n    }\n}\n\n/**\n * Registers given event listener on `target` element and returns event binding\n * object to unregister event\n */\nfunction addEvent(target, type, listener, host, scope) {\n    return registerBinding(type, { host, scope, target, listener, handleEvent });\n}\n/**\n * Unregister given event binding\n */\nfunction removeEvent(type, binding) {\n    binding.target.removeEventListener(type, binding);\n}\n/**\n * Creates structure for collecting pending events\n */\nfunction pendingEvents(host, target) {\n    return { host, target, events: obj() };\n}\nfunction setPendingEvent(pending, type, listener, scope) {\n    let binding = pending.events[type];\n    if (binding) {\n        binding.listener = listener;\n        binding.scope = scope;\n    }\n    else {\n        binding = pending.events[type] = addEvent(pending.target, type, listener, pending.host, scope);\n    }\n    binding.pending = listener;\n}\nfunction finalizePendingEvents(pending) {\n    // For event listeners, we should only bind or unbind events, depending\n    // on current listener value\n    const { events } = pending;\n    for (const type in events) {\n        const binding = events[type];\n        if (binding) {\n            if (!binding.pending) {\n                events[type] = removeEvent(type, binding);\n            }\n            binding.pending = void 0;\n        }\n    }\n}\nfunction detachPendingEvents(pending) {\n    const { events } = pending;\n    for (const type in events) {\n        const binding = events[type];\n        if (binding) {\n            removeEvent(type, binding);\n        }\n    }\n}\nfunction handleEvent(event) {\n    try {\n        this.listener && this.listener(this.host, event, this.target, this.scope);\n    }\n    catch (error) {\n        runtimeError(this.host, error);\n        // tslint:disable-next-line:no-console\n        console.error(error);\n    }\n}\nfunction safeEventListener(host, handler) {\n    // tslint:disable-next-line:only-arrow-functions\n    return function (event) {\n        try {\n            handler.call(this, event);\n        }\n        catch (error) {\n            runtimeError(host, error);\n            // tslint:disable-next-line:no-console\n            console.error(error);\n        }\n    };\n}\nfunction registerBinding(type, binding) {\n    binding.target.addEventListener(type, binding);\n    return binding;\n}\n\n/**\n * Creates new attribute change set\n */\nfunction attributeSet() {\n    return { c: obj(), p: obj() };\n}\n/**\n * Create pending props change set\n */\nfunction propsSet(elem) {\n    const props = assign(obj(), elem.componentModel.defaultProps);\n    // NB in components, pending `c` props are tested against actual `.props`,\n    // the `p` property is not used. To keep up with the same hidden JS class,\n    // create `p` property as well and point it to `c` to reduce object allocations\n    return { c: props, p: props };\n}\n/**\n * Alias for `elem.setAttribute`\n */\nfunction setAttribute(elem, name, value) {\n    elem.setAttribute(name, value);\n    return value;\n}\n/**\n * Alias for `elem.className`\n */\nfunction setClass(elem, value) {\n    elem.className = value;\n    return value;\n}\n/**\n * Sets attribute value as expression. Unlike regular primitive attributes,\n * expression values must be represented, e.g. non-primitive values must be\n * converted to string representations. Also, expression resolved to `false`,\n * `null` or `undefined` will remove attribute from element\n */\nfunction setAttributeExpression(elem, name, value) {\n    const primitive = representedValue(value);\n    primitive === null\n        ? elem.removeAttribute(name)\n        : setAttribute(elem, name, primitive);\n    return value;\n}\n/**\n * Updates attribute value only if it’s not equal to previous value\n */\nfunction updateAttributeExpression(elem, name, value, prevValue) {\n    return prevValue !== value\n        ? setAttributeExpression(elem, name, value)\n        : value;\n}\n/**\n * Alias for `elem.setAttributeNS`\n */\nfunction setAttributeNS(elem, ns, name, value) {\n    elem.setAttributeNS(ns, name, value);\n    return value;\n}\n/**\n * Same as `setAttributeExpression()` but for namespaced attributes\n */\nfunction setAttributeExpressionNS(elem, ns, name, value) {\n    const primitive = representedValue(value);\n    primitive === null\n        ? elem.removeAttributeNS(ns, name)\n        : setAttributeNS(elem, ns, name, primitive);\n    return value;\n}\n/**\n * Adds or removes (if value is `void`) attribute to given element\n */\nfunction updateAttributeExpressionNS(elem, ns, name, value, prevValue) {\n    return prevValue !== value\n        ? setAttributeExpressionNS(elem, ns, name, value)\n        : value;\n}\n/**\n * Alias for `elem.classList.add()`\n */\nfunction addClass(elem, className) {\n    elem.classList.add(className);\n}\n/**\n * Adds class to given element if given condition is truthy\n */\nfunction addClassIf(elem, className, condition) {\n    condition && addClass(elem, className);\n    return condition;\n}\n/**\n * Toggles class on given element if condition is changed\n */\nfunction toggleClassIf(elem, className, condition, prevResult) {\n    if (prevResult !== condition) {\n        condition ? addClass(elem, className) : elem.classList.remove(className);\n    }\n    return condition;\n}\n/**\n * Sets pending attribute value which will be added to attribute later\n */\nfunction setPendingAttribute(data, name, value) {\n    data.c[name] = value;\n}\n/**\n * Sets pending namespaced attribute value which will be added to attribute later\n */\nfunction setPendingAttributeNS(data, ns, name, value) {\n    if (!data.n) {\n        data.n = obj();\n    }\n    if (!data.n[ns]) {\n        data.n[ns] = attributeSet();\n    }\n    data.n[ns].c[name] = value;\n}\n/**\n * Adds given class name to pending attribute set\n */\nfunction addPendingClass(data, className) {\n    if (className != null) {\n        const prev = data.c.class;\n        data.c.class = prev ? prev + ' ' + className : String(className);\n    }\n}\n/**\n * Adds given class name to pending attribute set if condition is truthy\n */\nfunction addPendingClassIf(data, className, condition) {\n    condition && addPendingClass(data, className);\n}\n/**\n * Finalizes pending attributes\n */\nfunction finalizeAttributes(elem, data) {\n    let updated = 0;\n    const { c, p } = data;\n    for (const name in c) {\n        const curValue = c[name];\n        if (curValue !== p[name]) {\n            updated = 1;\n            if (name === 'class') {\n                elem.className = classNames(curValue).join(' ');\n            }\n            else {\n                setAttributeExpression(elem, name, curValue);\n            }\n            p[name] = curValue;\n        }\n        c[name] = null;\n    }\n    return updated;\n}\n/**\n * Finalizes pending namespaced attributes\n */\nfunction finalizeAttributesNS(elem, data) {\n    // NB use it as a separate function to use explicitly inside generated content.\n    // It there’s no pending namespace attributes, this method will not be included\n    // into final bundle\n    if (!data.n) {\n        return 0;\n    }\n    let updated = 0;\n    for (const ns in data.n) {\n        const { c, p } = data.n[ns];\n        for (const name in c) {\n            const curValue = c[name];\n            if (curValue !== p[name]) {\n                updated = 1;\n                setAttributeExpressionNS(elem, ns, name, curValue);\n                p[name] = curValue;\n            }\n            c[name] = null;\n        }\n    }\n    return updated;\n}\n/**\n * Returns normalized list of class names from given string\n */\nfunction classNames(str) {\n    const out = [];\n    if (isDefined(str)) {\n        const parts = String(str).split(/\\s+/);\n        for (let i = 0, cl; i < parts.length; i++) {\n            cl = parts[i];\n            if (cl && out.indexOf(cl) === -1) {\n                out.push(cl);\n            }\n        }\n    }\n    return out;\n}\n/**\n * Returns represented attribute value for given data\n */\nfunction representedValue(value) {\n    if (value === false || !isDefined(value)) {\n        return null;\n    }\n    if (value === true) {\n        return '';\n    }\n    if (Array.isArray(value)) {\n        return '[]';\n    }\n    if (typeof value === 'function') {\n        return '𝑓';\n    }\n    if (typeof value === 'object') {\n        return '{}';\n    }\n    return value;\n}\n\n/**\n * Creates linted list\n */\n/**\n * Creates linked list item\n */\nfunction createListItem(value) {\n    return { value, next: null, prev: null };\n}\n/**\n * Prepends given value to linked list\n */\nfunction listPrependValue(list, value) {\n    const item = createListItem(value);\n    if (item.next = list.head) {\n        item.next.prev = item;\n    }\n    return list.head = item;\n}\n/**\n * Inserts given value after given `ref` item\n */\nfunction listInsertValueAfter(value, ref) {\n    const item = createListItem(value);\n    const { next } = ref;\n    ref.next = item;\n    item.prev = ref;\n    if (item.next = next) {\n        next.prev = item;\n    }\n    return item;\n}\n/**\n * Moves list fragment with `start` and `end` bounds right after `ref` item\n */\nfunction listMoveFragmentAfter(list, start, end, ref) {\n    listDetachFragment(list, start, end);\n    if (end.next = ref.next) {\n        end.next.prev = end;\n    }\n    ref.next = start;\n    start.prev = ref;\n}\n/**\n * Moves list fragment with `start` and `end` to list head\n */\nfunction listMoveFragmentFirst(list, start, end) {\n    listDetachFragment(list, start, end);\n    if (end.next = list.head) {\n        end.next.prev = end;\n    }\n    list.head = start;\n}\n/**\n * Detaches list fragment with `start` and `end` from list\n */\nfunction listDetachFragment(list, start, end) {\n    const { prev } = start;\n    const { next } = end;\n    if (prev) {\n        prev.next = next;\n    }\n    else {\n        list.head = next;\n    }\n    if (next) {\n        next.prev = prev;\n    }\n    start.prev = end.next = null;\n}\n\n/**\n * Creates injector instance for given target, if required\n */\nfunction createInjector(target) {\n    return {\n        parentNode: target,\n        head: null,\n        ptr: null,\n        // NB create `slots` placeholder to promote object to hidden class.\n        // Do not use any additional function argument for adding value to `slots`\n        // to reduce runtime checks and keep functions in monomorphic state\n        slots: null\n    };\n}\n/**\n * Inserts given node into current context\n */\nfunction insert(injector, node, slotName = '') {\n    const { slots, ptr } = injector;\n    const target = slots\n        ? getSlotContext(injector, slotName).element\n        : injector.parentNode;\n    domInsert(node, target, ptr ? getAnchorNode(ptr.next, target) : void 0);\n    injector.ptr = ptr ? listInsertValueAfter(node, ptr) : listPrependValue(injector, node);\n    return node;\n}\n/**\n * Injects given block\n */\nfunction injectBlock(injector, block) {\n    const { ptr } = injector;\n    if (ptr) {\n        block.end = listInsertValueAfter(block, ptr);\n        block.start = listInsertValueAfter(block, ptr);\n    }\n    else {\n        block.end = listPrependValue(injector, block);\n        block.start = listPrependValue(injector, block);\n    }\n    block.$$block = true;\n    injector.ptr = block.end;\n    return block;\n}\n/**\n * Returns named slot context from given component input’s injector. If slot context\n * doesn’t exists, it will be created\n */\nfunction getSlotContext(injector, name) {\n    const slots = injector.slots;\n    return slots[name] || (slots[name] = createSlotContext(name));\n}\n/**\n * Empties content of given block\n */\nfunction emptyBlockContent(block) {\n    const unmount = block.mount && block.mount.dispose;\n    if (unmount) {\n        unmount(block.scope, block.host);\n    }\n    let item = block.start.next;\n    while (item && item !== block.end) {\n        // tslint:disable-next-line:prefer-const\n        let { value, next, prev } = item;\n        if (isBlock(value)) {\n            next = value.end.next;\n            disposeBlock(value);\n        }\n        else if (!value[animatingKey]) {\n            domRemove(value);\n        }\n        // NB: Block always contains `.next` and `.prev` items which are block\n        // bounds so we can safely skip null check here\n        prev.next = next;\n        next.prev = prev;\n        item = next;\n    }\n}\n/**\n * Moves contents of `block` after `ref` list item\n */\nfunction move(injector, block, ref) {\n    if (ref && ref.next && ref.next.value === block) {\n        return;\n    }\n    // Update linked list\n    const { start, end } = block;\n    if (ref) {\n        listMoveFragmentAfter(injector, start, end, ref);\n    }\n    else {\n        listMoveFragmentFirst(injector, start, end);\n    }\n    // Move block contents in DOM\n    let item = start.next;\n    let node;\n    while (item && item !== end) {\n        if (!isBlock(item.value)) {\n            node = item.value;\n            // NB it’s possible that a single block contains nodes from different\n            // slots so we have to find anchor for each node individually\n            domInsert(node, node.parentNode, getAnchorNode(end.next, node.parentNode));\n        }\n        item = item.next;\n    }\n}\n/**\n * Disposes given block\n */\nfunction disposeBlock(block) {\n    emptyBlockContent(block);\n    listDetachFragment(block.injector, block.start, block.end);\n    // @ts-ignore: Nulling disposed object\n    block.start = block.end = null;\n}\n/**\n * Check if given value is a block\n */\nfunction isBlock(obj) {\n    return '$$block' in obj;\n}\n/**\n * Get DOM node nearest to given position of items list\n */\nfunction getAnchorNode(item, parent) {\n    while (item) {\n        if (item.value.parentNode === parent) {\n            return item.value;\n        }\n        item = item.next;\n    }\n}\n/**\n * Creates context for given slot\n */\nfunction createSlotContext(name) {\n    const element = document.createElement('slot');\n    name && element.setAttribute('name', name);\n    return {\n        name,\n        element,\n        isDefault: false,\n        defaultContent: null\n    };\n}\n\n/**\n * Walks over each definition (including given one) and runs callback on it\n */\nfunction walkDefinitions(component, definition, fn) {\n    captureError(component, fn, definition);\n    const { plugins } = definition;\n    if (plugins) {\n        for (let i = 0; i < plugins.length; i++) {\n            walkDefinitions(component, plugins[i], fn);\n        }\n    }\n}\n/**\n * Same as `walkDefinitions` but runs in reverse order\n */\nfunction reverseWalkDefinitions(component, definition, fn) {\n    const { plugins } = definition;\n    if (plugins) {\n        let i = plugins.length;\n        while (i--) {\n            reverseWalkDefinitions(component, plugins[i], fn);\n        }\n    }\n    captureError(component, fn, definition);\n}\n/**\n * Invokes `name` hook for given component definition\n */\nfunction runHook(component, name, arg1, arg2) {\n    walkDefinitions(component, component.componentModel.definition, dfn => {\n        const hook = dfn[name];\n        if (typeof hook === 'function') {\n            hook(component, arg1, arg2);\n        }\n    });\n}\n\n/**\n * Enters new variable scope context\n */\nfunction enterScope(host, incoming) {\n    return setScope(host, createScope(host, incoming));\n}\n/**\n * Exit from current variable scope\n */\nfunction exitScope(host) {\n    return setScope(host, Object.getPrototypeOf(host.componentModel.vars));\n}\n/**\n * Creates new scope from given component state\n */\nfunction createScope(host, incoming) {\n    return assign(obj(host.componentModel.vars), incoming);\n}\n/**\n * Sets given object as current component scope\n */\nfunction setScope(host, scope) {\n    return host.componentModel.vars = scope;\n}\n/**\n * Returns current variable scope\n */\nfunction getScope(elem) {\n    return elem.componentModel.vars;\n}\n/**\n * Returns property with given name from component\n */\nfunction getProp(elem, name) {\n    return elem.props[name];\n}\n/**\n * Returns state value with given name from component\n */\nfunction getState(elem, name) {\n    return elem.state[name];\n}\n/**\n * Returns value of given runtime variable from component\n */\nfunction getVar(elem, name) {\n    return elem.componentModel.vars[name];\n}\n/**\n * Sets value of given runtime variable for component\n */\nfunction setVar(elem, name, value) {\n    elem.componentModel.vars[name] = value;\n}\n\n/**\n * Creates slot element\n */\nfunction createSlot(host, name, cssScope) {\n    return isolateElement(getSlotContext(host.componentModel.input, name).element, cssScope);\n}\n/**\n * Mounts slot context\n */\nfunction mountSlot(host, name, defaultContent) {\n    const injector = host.componentModel.input;\n    const ctx = getSlotContext(injector, name);\n    if (defaultContent) {\n        // Add block with default slot content\n        ctx.defaultContent = injectBlock(injector, {\n            host,\n            injector,\n            scope: getScope(host),\n            content: defaultContent,\n            mount: void 0,\n            update: void 0\n        });\n    }\n    if (isEmpty(ctx)) {\n        // No incoming content, mount default content\n        renderDefaultContent(ctx);\n    }\n    else {\n        setSlotted(ctx, true);\n    }\n    return ctx;\n}\n/**\n * Handles possible update of incoming data\n */\nfunction updateIncomingSlot(host, name, updated) {\n    const ctx = getSlotContext(host.componentModel.input, name);\n    if (updated) {\n        // Incoming content was updated but there’s default content mounted\n        if (ctx.isDefault) {\n            const block = ctx.defaultContent;\n            if (block) {\n                emptyBlockContent(block);\n                block.mount = void 0;\n            }\n            setSlotted(ctx, true);\n        }\n        notifySlotUpdate(host, ctx);\n    }\n    if (!ctx.isDefault && isEmpty(ctx)) {\n        // If slot content is empty, ensure default content is rendered\n        renderDefaultContent(ctx);\n    }\n}\n/**\n * Updates default slot content only if it was already rendered\n */\nfunction updateDefaultSlot(ctx) {\n    if (ctx.isDefault) {\n        const block = ctx.defaultContent;\n        if (block.update) {\n            block.update(block.host, block.scope);\n        }\n    }\n}\n/**\n * Unmounts default content of given slot context\n */\nfunction unmountSlot(ctx) {\n    const block = ctx.defaultContent;\n    if (block) {\n        disposeBlock(block);\n        setSlotted(ctx, false);\n        ctx.isDefault = false;\n        ctx.defaultContent = null;\n    }\n}\nfunction notifySlotUpdate(host, ctx) {\n    runHook(host, 'didSlotUpdate', ctx.name, ctx.element);\n}\n/**\n * Renders default slot content\n */\nfunction renderDefaultContent(ctx) {\n    if (ctx.defaultContent) {\n        const block = ctx.defaultContent;\n        const { injector } = block;\n        injector.ptr = block.start;\n        block.mount = block.content;\n        block.update = block.mount(block.host, injector, block.scope);\n        injector.ptr = block.end;\n    }\n    setSlotted(ctx, false);\n}\n/**\n * Check if given slot is empty\n */\nfunction isEmpty(ctx) {\n    // TODO better check for input content?\n    return !ctx.element.childNodes.length;\n}\n/**\n * Toggles slotted state in slot container\n */\nfunction setSlotted(ctx, slotted) {\n    ctx.isDefault = !slotted;\n    slotted ? ctx.element.setAttribute('slotted', '') : ctx.element.removeAttribute('slotted');\n}\n\nlet renderQueue = null;\n/**\n * Creates Endorphin DOM component with given definition\n */\nfunction createComponent(name, definition, host) {\n    let cssScope;\n    let root;\n    if (host && 'componentModel' in host) {\n        cssScope = host.componentModel.definition.cssScope;\n        root = host.root || host;\n    }\n    const element = elem(name, cssScope);\n    // Add host scope marker: we can’t rely on tag name since component\n    // definition is bound to element in runtime, not compile time\n    if (definition.cssScope) {\n        element.setAttribute(definition.cssScope + '-host', '');\n    }\n    const { props, state, extend, events } = prepare(element, definition);\n    element.refs = obj();\n    element.props = obj();\n    element.state = state;\n    element.componentView = element; // XXX Should point to Shadow Root in Web Components\n    root && (element.root = root);\n    addPropsState(element);\n    if (extend) {\n        Object.defineProperties(element, extend);\n    }\n    if (definition.store) {\n        element.store = definition.store();\n    }\n    else if (root && root.store) {\n        element.store = root.store;\n    }\n    // Create slotted input\n    const input = createInjector(element.componentView);\n    input.slots = obj();\n    element.componentModel = {\n        definition,\n        input,\n        vars: obj(),\n        mounted: false,\n        rendering: false,\n        update: void 0,\n        queued: false,\n        events,\n        defaultProps: props\n    };\n    runHook(element, 'init');\n    return element;\n}\n/**\n * Mounts given component\n */\nfunction mountComponent(component, props) {\n    const { componentModel } = component;\n    const { input, definition } = componentModel;\n    const changes = setPropsInternal(component, props || componentModel.defaultProps);\n    const arg = changes || {};\n    componentModel.rendering = true;\n    // Notify slot status\n    for (const p in input.slots) {\n        notifySlotUpdate(component, input.slots[p]);\n    }\n    if (changes) {\n        runHook(component, 'didChange', arg);\n    }\n    runHook(component, 'willMount', arg);\n    runHook(component, 'willRender', arg);\n    componentModel.update = captureError(component, definition.default, component, getScope(component));\n    componentModel.mounted = true;\n    componentModel.rendering = false;\n    runHook(component, 'didRender', arg);\n    runHook(component, 'didMount', arg);\n}\n/**\n * Updates given mounted component\n */\nfunction updateComponent(component, props) {\n    const changes = props && setPropsInternal(component, props);\n    if (changes || component.componentModel.queued) {\n        renderNext(component, changes);\n    }\n    return changes ? 1 : 0;\n}\n/**\n * Destroys given component: removes static event listeners and cleans things up\n * @returns Should return nothing since function result will be used\n * as shorthand to reset cached value\n */\nfunction unmountComponent(component) {\n    const { componentModel } = component;\n    const { definition, events } = componentModel;\n    runHook(component, 'willUnmount');\n    componentModel.mounted = false;\n    if (events) {\n        detachStaticEvents(component, events);\n    }\n    if (component.store) {\n        component.store.unwatch(component);\n    }\n    const dispose = definition.default && definition.default.dispose;\n    captureError(component, dispose, getScope(component));\n    runHook(component, 'didUnmount');\n    // @ts-ignore: Nulling disposed object\n    component.componentModel = null;\n}\n/**\n * Subscribes to store updates of given component\n */\nfunction subscribeStore(component, keys) {\n    if (!component.store) {\n        throw new Error(`Store is not defined for ${component.nodeName} component`);\n    }\n    component.store.watch(component, keys);\n}\n/**\n * Queues next component render\n */\nfunction renderNext(component, changes) {\n    if (!component.componentModel.rendering) {\n        renderComponent(component, changes);\n    }\n    else {\n        scheduleRender(component, changes);\n    }\n}\n/**\n * Schedules render of given component on next tick\n */\nfunction scheduleRender(component, changes) {\n    if (!component.componentModel.queued) {\n        component.componentModel.queued = true;\n        if (renderQueue) {\n            renderQueue.push(component, changes);\n        }\n        else {\n            renderQueue = [component, changes];\n            requestAnimationFrame(drainQueue);\n        }\n    }\n}\n/**\n * Renders given component\n */\nfunction renderComponent(component, changes) {\n    const { componentModel } = component;\n    const arg = changes || {};\n    componentModel.queued = false;\n    componentModel.rendering = true;\n    if (changes) {\n        runHook(component, 'didChange', arg);\n    }\n    runHook(component, 'willUpdate', arg);\n    runHook(component, 'willRender', arg);\n    captureError(component, componentModel.update, component, getScope(component));\n    componentModel.rendering = false;\n    runHook(component, 'didRender', arg);\n    runHook(component, 'didUpdate', arg);\n}\n/**\n * Removes attached events from given map\n */\nfunction detachStaticEvents(component, eventMap) {\n    const { listeners, handler } = eventMap;\n    for (const p in listeners) {\n        component.removeEventListener(p, handler);\n    }\n}\nfunction kebabCase(ch) {\n    return '-' + ch.toLowerCase();\n}\nfunction setPropsInternal(component, nextProps) {\n    let changes;\n    const { props } = component;\n    const { defaultProps } = component.componentModel;\n    for (const p in nextProps) {\n        const prev = props[p];\n        let current = nextProps[p];\n        if (current == null) {\n            nextProps[p] = current = defaultProps[p];\n        }\n        if (p === 'class' && current != null) {\n            current = classNames(current).join(' ');\n        }\n        if (current !== prev) {\n            if (!changes) {\n                changes = obj();\n            }\n            props[p] = current;\n            changes[p] = { current, prev };\n            if (!/^partial:/.test(p)) {\n                representAttributeValue(component, p.replace(/[A-Z]/g, kebabCase), current);\n            }\n        }\n    }\n    return changes;\n}\n/**\n * Check if `next` contains value that differs from one in `prev`\n */\nfunction hasChanges(prev, next) {\n    for (const p in next) {\n        if (next[p] !== prev[p]) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Prepares internal data for given component\n */\nfunction prepare(component, definition) {\n    const props = obj();\n    const state = obj();\n    let events;\n    let extend;\n    reverseWalkDefinitions(component, definition, dfn => {\n        dfn.props && assign(props, dfn.props(component));\n        dfn.state && assign(state, dfn.state(component));\n        // NB: backward compatibility with previous implementation\n        if (dfn.methods) {\n            extend = getDescriptors(dfn.methods, extend);\n        }\n        if (dfn.extend) {\n            extend = getDescriptors(dfn.extend, extend);\n        }\n        if (dfn.events) {\n            if (!events) {\n                events = createEventsMap(component);\n            }\n            attachEventHandlers(component, dfn.events, events);\n        }\n    });\n    return { props, state, extend, events };\n}\n/**\n * Extracts property descriptors from given source object and merges it with `prev`\n * descriptor map, if given\n */\nfunction getDescriptors(source, prev) {\n    const descriptors = getObjectDescriptors(source);\n    return prev ? assign(prev, descriptors) : descriptors;\n}\nfunction createEventsMap(component) {\n    const listeners = obj();\n    const handler = function (evt) {\n        if (component.componentModel) {\n            const handlers = listeners[evt.type];\n            for (let i = 0; i < handlers.length; i++) {\n                handlers[i](component, evt, this);\n            }\n        }\n    };\n    return { handler: safeEventListener(component, handler), listeners };\n}\nfunction attachEventHandlers(component, events, eventMap) {\n    const names = Object.keys(events);\n    const { listeners } = eventMap;\n    for (let i = 0, name; i < names.length; i++) {\n        name = names[i];\n        if (name in listeners) {\n            listeners[name].push(events[name]);\n        }\n        else {\n            component.addEventListener(name, eventMap.handler);\n            listeners[name] = [events[name]];\n        }\n    }\n}\nfunction addPropsState(element) {\n    element.setProps = function setProps(value) {\n        const { componentModel } = element;\n        // In case of calling `setProps` after component was unmounted,\n        // check if `componentModel` is available\n        if (value != null && componentModel && componentModel.mounted) {\n            const changes = setPropsInternal(element, assign(obj(), value));\n            changes && renderNext(element, changes);\n            return changes;\n        }\n    };\n    element.setState = function setState(value) {\n        const { componentModel } = element;\n        // In case of calling `setState` after component was unmounted,\n        // check if `componentModel` is available\n        if (value != null && componentModel && hasChanges(element.state, value)) {\n            assign(element.state, value);\n            // If we’re in rendering state than current `setState()` is caused by\n            // one of the `will*` hooks, which means applied changes will be automatically\n            // applied during rendering stage.\n            // If called outside of rendering state we should schedule render\n            // on next tick\n            if (componentModel.mounted && !componentModel.rendering) {\n                scheduleRender(element);\n            }\n        }\n    };\n}\nfunction drainQueue() {\n    const pending = renderQueue;\n    renderQueue = null;\n    for (let i = 0, component; i < pending.length; i += 2) {\n        component = pending[i];\n        // It’s possible that a component can be rendered before next tick\n        // (for example, if parent node updated component props).\n        // Check if it’s still queued then render.\n        // Also, component can be unmounted after it’s rendering was scheduled\n        if (component.componentModel && component.componentModel.queued) {\n            renderComponent(component, pending[i + 1]);\n        }\n    }\n}\n\nfunction mountBlock(host, injector, get) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        get,\n        mount: undefined,\n        update: undefined\n    });\n    updateBlock(block);\n    return block;\n}\n/**\n * Updated block, described in `ctx` object\n * @returns Returns `1` if block was updated, `0` otherwise\n */\nfunction updateBlock(block) {\n    let updated = 0;\n    const { host, injector, scope } = block;\n    const mount = block.get(host, scope);\n    if (block.mount !== mount) {\n        updated = 1;\n        // Unmount previously rendered content\n        block.mount && emptyBlockContent(block);\n        // Mount new block content\n        injector.ptr = block.start;\n        block.mount = mount;\n        block.update = mount && mount(block.host, injector, scope);\n    }\n    else if (block.update) {\n        // Update rendered result\n        updated = block.update(host, scope) ? 1 : 0;\n    }\n    block.injector.ptr = block.end;\n    return updated;\n}\nfunction unmountBlock(block) {\n    disposeBlock(block);\n}\n\n/**\n * Mounts iterator block\n * @param get A function that returns collection to iterate\n * @param body A function that renders item of iterated collection\n */\nfunction mountIterator(host, injector, get, body) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        get,\n        body,\n        index: 0,\n        updated: 0\n    });\n    updateIterator(block);\n    return block;\n}\n/**\n * Updates iterator block defined in `ctx`\n * @returns Returns `1` if iterator was updated, `0` otherwise\n */\nfunction updateIterator(block) {\n    const { injector } = block;\n    injector.ptr = block.start;\n    block.index = block.updated = 0;\n    const collection = block.get(block.host, block.scope);\n    if (collection && typeof collection.forEach === 'function') {\n        collection.forEach(iterator, block);\n    }\n    trimIteratorItems(block, injector.ptr.next);\n    injector.ptr = block.end;\n    return block.updated;\n}\nfunction unmountIterator(block) {\n    disposeBlock(block);\n}\nfunction prepareScope(scope, index, key, value) {\n    scope.index = index;\n    scope.key = key;\n    scope.value = value;\n    return scope;\n}\n/**\n * Removes remaining iterator items from current context\n */\nfunction trimIteratorItems(block, start) {\n    let listItem;\n    while (start !== block.end) {\n        block.updated = 1;\n        listItem = start.value;\n        start = listItem.end.next;\n        disposeBlock(listItem);\n    }\n}\nfunction iterator(value, key) {\n    const { host, injector, index, body, end } = this;\n    const { next } = injector.ptr;\n    const prevScope = getScope(host);\n    let rendered;\n    if (next !== end) {\n        rendered = next.value;\n        // We have rendered item, update it\n        if (rendered.update) {\n            const scope = prepareScope(rendered.scope, index, key, value);\n            setScope(host, scope);\n            if (rendered.update(host, scope)) {\n                this.updated = 1;\n            }\n            setScope(host, prevScope);\n        }\n    }\n    else {\n        // Create & render new block\n        const scope = prepareScope(obj(prevScope), index, key, value);\n        rendered = injectBlock(injector, {\n            host,\n            injector,\n            scope,\n            mount: body,\n            update: undefined,\n        });\n        setScope(host, scope);\n        injector.ptr = rendered.start;\n        rendered.update = body(host, injector, scope);\n        setScope(host, prevScope);\n        this.updated = 1;\n    }\n    injector.ptr = rendered.end;\n    this.index++;\n}\n\n/**\n * Renders key iterator block\n */\nfunction mountKeyIterator(host, injector, get, keyExpr, body) {\n    const parentScope = getScope(host);\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: obj(parentScope),\n        get,\n        body,\n        keyExpr,\n        index: 0,\n        updated: 0,\n        used: null,\n        rendered: null,\n        needReorder: false,\n        parentScope,\n        order: []\n    });\n    updateKeyIterator(block);\n    return block;\n}\n/**\n * Updates iterator block defined in `ctx`\n * @returns Returns `1` if iterator was updated, `0` otherwise\n */\nfunction updateKeyIterator(block) {\n    const { host, injector, rendered } = block;\n    injector.ptr = block.start;\n    block.used = obj();\n    block.index = block.updated = 0;\n    block.needReorder = false;\n    const collection = block.get(host, block.parentScope);\n    if (collection && typeof collection.forEach === 'function') {\n        const prevScope = getScope(host);\n        collection.forEach(keyIterator, block);\n        setScope(host, prevScope);\n    }\n    if (rendered) {\n        block.updated |= disposeLookup(rendered);\n    }\n    if (block.needReorder) {\n        block.updated = 1;\n        reorder(block);\n    }\n    block.order.length = 0;\n    block.rendered = block.used;\n    injector.ptr = block.end;\n    return block.updated;\n}\nfunction unmountKeyIterator(block) {\n    disposeBlock(block);\n}\nfunction getItem(listItem, bound) {\n    return listItem !== bound ? listItem.value : null;\n}\nfunction keyIterator(value, key) {\n    const { injector, index, rendered } = this;\n    const id = this.keyExpr(value, prepareScope(this.scope, index, key, value));\n    let entry = rendered && getLookup(rendered, id);\n    if (entry) {\n        if (entry.start.prev !== injector.ptr) {\n            this.needReorder = true;\n        }\n        this.updated |= updateEntry(entry, value, key, index);\n    }\n    else {\n        entry = mountEntry(this, value, key, index);\n        this.updated = 1;\n    }\n    putLookup(this.used, id, entry);\n    this.order.push(entry);\n    injector.ptr = entry.end;\n    this.index++;\n}\nfunction mountEntry(block, value, key, index) {\n    const { host, injector, body: mount } = block;\n    const scope = prepareScope(obj(block.scope), index, key, value);\n    setScope(host, scope);\n    const entry = injectBlock(injector, {\n        host,\n        injector,\n        scope,\n        mount,\n        update: undefined,\n        next: null\n    });\n    injector.ptr = entry.start;\n    entry.update = mount && mount(host, injector, scope);\n    return entry;\n}\nfunction updateEntry(entry, value, key, index) {\n    if (entry.update) {\n        const { host } = entry;\n        const scope = prepareScope(entry.scope, index, key, value);\n        setScope(host, scope);\n        if (entry.update(host, scope)) {\n            return 1;\n        }\n    }\n    return 0;\n}\nfunction reorder(block) {\n    const { injector, order } = block;\n    let actualPrev;\n    let actualNext;\n    let expectedPrev;\n    let expectedNext;\n    const { start, end } = block;\n    for (let i = 0, maxIx = order.length - 1, item; i <= maxIx; i++) {\n        item = order[i];\n        expectedPrev = i > 0 ? order[i - 1] : null;\n        expectedNext = i < maxIx ? order[i + 1] : null;\n        actualPrev = getItem(item.start.prev, start);\n        actualNext = getItem(item.end.next, end);\n        if (expectedPrev !== actualPrev && expectedNext !== actualNext) {\n            // Blocks must be reordered\n            move(injector, item, expectedPrev ? expectedPrev.end : block.start);\n        }\n    }\n}\nfunction getLookup(lookup, key) {\n    const item = lookup[key];\n    if (item && (lookup[key] = item.next)) {\n        item.next = null;\n    }\n    return item;\n}\nfunction putLookup(lookup, key, value) {\n    value.next = lookup[key];\n    lookup[key] = value;\n}\nfunction disposeLookup(lookup) {\n    let updated = 0;\n    for (const p in lookup) {\n        let item = lookup[p];\n        while (item) {\n            updated = 1;\n            disposeBlock(item);\n            item = item.next;\n        }\n    }\n    return updated;\n}\n\n/**\n * Adds given element as a named ref\n */\nfunction setRef(host, key, elem) {\n    elem.setAttribute(getRefAttr(key, host), '');\n    host.refs[key] = elem;\n}\n/**\n * Removes ref for given key\n */\nfunction removeRef(host, key) {\n    const elem = host.refs[key];\n    if (elem) {\n        elem.removeAttribute(getRefAttr(key, host));\n        host.refs[key] = null;\n    }\n}\nfunction setPendingRef(pending, key, elem) {\n    if (key && elem) {\n        pending[key] = elem;\n    }\n}\nfunction finalizePendingRefs(host, pending) {\n    for (const key in pending) {\n        const prev = host.refs[key];\n        const next = pending[key];\n        if (prev !== next) {\n            prev && removeRef(host, key);\n            next && setRef(host, key, next);\n        }\n        pending[key] = null;\n    }\n}\n/**\n * Returns attribute name to identify element in CSS\n */\nfunction getRefAttr(name, host) {\n    const cssScope = host.componentModel.definition.cssScope;\n    return 'ref-' + name + (cssScope ? '-' + cssScope : '');\n}\n\n/**\n * Renders code, returned from `get` function, as HTML\n */\nfunction mountInnerHTML(host, injector, get, slotName) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        get,\n        code: null,\n        slotName\n    });\n    updateInnerHTML(block);\n    return block;\n}\n/**\n * Updates inner HTML of block, defined in `ctx`\n * @returns Returns `1` if inner HTML was updated, `0` otherwise\n */\nfunction updateInnerHTML(block) {\n    const { host, injector, scope } = block;\n    const code = block.get(host, scope);\n    if (code !== block.code) {\n        emptyBlockContent(block);\n        if (isDefined(block.code = code)) {\n            injector.ptr = block.start;\n            renderHTML(host, injector, code, block.slotName);\n        }\n        injector.ptr = block.end;\n        return 1;\n    }\n    return 0;\n}\nfunction unmountInnerHTML(block) {\n    disposeBlock(block);\n}\nfunction renderHTML(host, injector, code, slotName) {\n    const { cssScope } = host.componentModel.definition;\n    if (code && code.nodeType) {\n        // Insert as DOM element\n        cssScope && scopeDOM(code, cssScope);\n        insert(injector, code, slotName);\n    }\n    else {\n        // Render as HTML\n        const div = document.createElement('div');\n        div.innerHTML = code;\n        cssScope && scopeDOM(div, cssScope);\n        while (div.firstChild) {\n            insert(injector, div.firstChild, slotName);\n        }\n    }\n}\n/**\n * Scopes CSS of all elements in given node\n */\nfunction scopeDOM(node, cssScope) {\n    node = node.firstChild;\n    while (node) {\n        if (node.nodeType === node.ELEMENT_NODE) {\n            isolateElement(node, cssScope);\n            scopeDOM(node, cssScope);\n        }\n        node = node.nextSibling;\n    }\n}\n\nfunction getPartial(host, name, componentPartials) {\n    return host.props['partial:' + name] || componentPartials[name];\n}\n/**\n * Mounts given partial into injector context\n */\nfunction mountPartial(host, injector, partial, args) {\n    const block = injectBlock(injector, {\n        host,\n        injector,\n        scope: getScope(host),\n        mount: void 0,\n        update: void 0,\n        partial: null\n    });\n    updatePartial(block, partial, args);\n    return block;\n}\n/**\n * Updates mounted partial\n * @returns Returns `1` if partial was updated, `0` otherwise\n */\nfunction updatePartial(block, partial, args) {\n    const host = partial.host || block.host;\n    const { injector } = block;\n    const prevHost = block.host;\n    const prevScope = getScope(host);\n    let updated = 0;\n    block.host = host;\n    if (block.partial !== partial) {\n        // Unmount previously rendered partial\n        block.partial && emptyBlockContent(block);\n        // Mount new partial\n        const scope = block.scope = assign(obj(prevScope), partial.defaults, args);\n        setScope(host, scope);\n        injector.ptr = block.start;\n        block.mount = partial && partial.body;\n        block.update = block.mount && block.mount(host, injector, scope);\n        block.partial = partial;\n        setScope(host, prevScope);\n        updated = 1;\n    }\n    else if (block.update) {\n        // Update rendered partial\n        const scope = setScope(host, assign(block.scope, args));\n        if (block.update(host, scope)) {\n            updated = 1;\n        }\n        setScope(host, prevScope);\n    }\n    block.host = prevHost;\n    injector.ptr = block.end;\n    return updated;\n}\nfunction unmountPartial(block) {\n    disposeBlock(block);\n}\n\nconst prefix = '$';\nclass Store {\n    constructor(data) {\n        this.sync = false;\n        this.listeners = [];\n        this.data = assign({}, data || {});\n    }\n    /**\n     * Returns current store data\n     */\n    get() {\n        return this.data;\n    }\n    /**\n     * Updates data in store\n     */\n    set(data) {\n        const updated = changed(data, this.data, prefix);\n        const render = this.sync ? renderComponent : scheduleRender;\n        if (updated) {\n            const next = this.data = assign(this.data, data);\n            // Notify listeners.\n            // Run in reverse order for listener safety (in case if handler decides\n            // to unsubscribe during notification)\n            for (let i = this.listeners.length - 1, item; i >= 0; i--) {\n                item = this.listeners[i];\n                if (!item.keys || !item.keys.length || hasChange(item.keys, updated)) {\n                    if ('component' in item) {\n                        render(item.component, updated);\n                    }\n                    else if ('handler' in item) {\n                        item.handler(next, updated);\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Subscribes to changes in given store\n     * @param handler Function to invoke when store changes\n     * @param keys Run handler only if given top-level keys are changed\n     * @returns Object that should be used to unsubscribe from updates\n     */\n    subscribe(handler, keys) {\n        const obj = {\n            handler,\n            keys: scopeKeys(keys, prefix)\n        };\n        this.listeners.push(obj);\n        return obj;\n    }\n    /**\n     * Unsubscribes from further updates\n     */\n    unsubscribe(obj) {\n        const ix = this.listeners.indexOf(obj);\n        if (ix !== -1) {\n            this.listeners.splice(ix, 1);\n        }\n    }\n    /**\n     * Watches for updates of given `keys` in store and runs `component` render on change\n     */\n    watch(component, keys) {\n        this.listeners.push({\n            component,\n            keys: scopeKeys(keys, prefix)\n        });\n    }\n    /**\n     * Stops watching for store updates for given component\n     * @param {Component} component\n     */\n    unwatch(component) {\n        for (let i = 0; i < this.listeners.length; i++) {\n            if (this.listeners[i].component === component) {\n                this.listeners.splice(i, 1);\n                return;\n            }\n        }\n    }\n}\n/**\n * Check if any of `keys` was changed in `next` object since `prev` state\n * @param {string[]} keys\n * @param {Object} updated\n * @return {boolean}\n */\nfunction hasChange(keys, updated) {\n    for (let i = 0; i < keys.length; i++) {\n        if (keys[i] in updated) {\n            return true;\n        }\n    }\n    return false;\n}\n/**\n * Adds given prefix to keys\n */\nfunction scopeKeys(keys, pfx) {\n    return keys && pfx ? keys.map(key => pfx + key) : keys;\n}\n\nconst pool = [];\nconst defaultTween = {\n    duration: 500,\n    delay: 0,\n    easing(t, b, c, d) {\n        return c * t / d + b;\n    }\n};\n// If `true` then no animations will be invoked\nlet blocked = false;\n/**\n * Starts animation on given element\n */\nfunction animate(elem, animation, callback) {\n    if (!blocked && animation) {\n        if (typeof animation === 'function') {\n            tweenAnimate(elem, animation, callback);\n        }\n        else {\n            cssAnimate(elem, animation, callback);\n        }\n    }\n    else if (callback) {\n        // Stop previous animation, if any\n        stopAnimation(elem, true);\n        callback();\n    }\n}\n/**\n * Starts CSS animation on given element\n */\nfunction cssAnimate(elem, animation, callback) {\n    // Stop previous animation, if any\n    stopAnimation(elem, true);\n    const prevAnimation = elem.style.animation;\n    elem[animatingKey] = (cancel) => {\n        elem.removeEventListener('animationend', handler);\n        elem.removeEventListener('animationcancel', handler);\n        elem.style.animation = prevAnimation;\n        !cancel && finalizeAnimation(callback);\n    };\n    const handler = (evt) => evt.target === elem && stopAnimation(elem);\n    elem.addEventListener('animationend', handler);\n    elem.addEventListener('animationcancel', handler);\n    elem.style.animation = animation;\n    // In case if callback is provided, we have to ensure that animation is actually applied.\n    // In some testing environments, animations could be disabled via\n    // `* { animation: none !important; }`. In this case, we should complete animation ASAP.\n    if (callback) {\n        nextTick(() => {\n            const style = window.getComputedStyle(elem, null);\n            if (!style.animationName || style.animationName === 'none') {\n                stopAnimation(elem);\n            }\n        });\n    }\n}\n/**\n * Starts JS animation on given element\n */\nfunction tweenAnimate(elem, animation, callback) {\n    // Stop previous animation, if any\n    const prevAnim = findTween(elem);\n    stopAnimation(elem, true);\n    let options = animation(elem);\n    if (options) {\n        options = assign({}, defaultTween, options);\n        if (typeof options.easing !== 'function') {\n            throw new Error('Easing must be a function');\n        }\n        const now = performance.now();\n        const offset = prevAnim\n            ? 1 - (now - prevAnim.start) / (prevAnim.end - prevAnim.start)\n            : 0;\n        const start = now + options.delay - (offset * options.duration);\n        const anim = {\n            elem,\n            options,\n            start,\n            end: start + options.duration,\n            started: false\n        };\n        pool.push(anim);\n        elem[animatingKey] = (cancel) => {\n            pool.splice(pool.indexOf(anim), 1);\n            options.complete && options.complete(elem, options);\n            !cancel && finalizeAnimation(callback);\n        };\n        if (pool.length === 1) {\n            tweenLoop(now);\n        }\n    }\n    else if (callback) {\n        callback();\n    }\n}\n/**\n * Creates animation CSS value with scoped animation name\n */\nfunction createAnimation(animation, cssScope) {\n    if (animation == null) {\n        return '';\n    }\n    const parts = String(animation).split(' ');\n    const name = parts[0].trim();\n    const globalPrefix = 'global:';\n    if (name.indexOf(globalPrefix) === 0) {\n        // Do not scope animation name, use globally defined animation name\n        parts[0] = name.slice(globalPrefix.length);\n    }\n    else if (cssScope) {\n        parts[0] = concat(name, cssScope);\n    }\n    return parts.join(' ').trim();\n}\n/**\n * Composes two tween options objects into single one: instead of simple `assign`,\n * callbacks from both tweens will be composed into a single call\n */\nfunction composeTween(tween1, tween2) {\n    const next = assign({}, tween1, tween2);\n    const callbacks = ['start', 'step', 'complete'];\n    for (let i = 0; i < callbacks.length; i++) {\n        const cbName = callbacks[i];\n        const cb1 = tween1 && tween1[cbName];\n        const cb2 = tween2 && tween2[cbName];\n        if (cb1 && cb2) {\n            next[cbName] = (elem, p1, p2) => {\n                cb1(elem, p1, p2);\n                cb2(elem, p1, p2);\n            };\n        }\n    }\n    return next;\n}\n/**\n * Finalizes current animation: invokes given callback and blocks all nested\n * animations\n */\nfunction finalizeAnimation(callback) {\n    if (callback) {\n        blocked = true;\n        safeCall(callback);\n        blocked = false;\n    }\n}\nfunction tweenLoop(now) {\n    for (let i = pool.length - 1, anim; i >= 0; i--) {\n        anim = pool[i];\n        const { elem, options } = anim;\n        if (now >= anim.start) {\n            if (!anim.started) {\n                anim.started = true;\n                options.start && options.start(elem, options);\n            }\n            const finished = now >= anim.end;\n            const pos = finished ? 1 : options.easing(now - anim.start, 0, 1, options.duration);\n            options.step && options.step(elem, pos, options);\n            if (finished) {\n                stopAnimation(elem);\n            }\n        }\n    }\n    if (pool.length) {\n        requestAnimationFrame(tweenLoop);\n    }\n}\nfunction stopAnimation(elem, cancel) {\n    const callback = elem && elem[animatingKey];\n    if (callback) {\n        elem[animatingKey] = null;\n        callback(cancel);\n    }\n}\n/**\n * Finds existing tween animation for given element, if any\n */\nfunction findTween(elem) {\n    for (let i = 0; i < pool.length; i++) {\n        if (pool[i].elem === elem) {\n            return pool[i];\n        }\n    }\n    return null;\n}\n/**\n * Concatenates two strings with optional separator\n */\nfunction concat(name, suffix) {\n    const sep = suffix[0] === '_' || suffix[0] === '-' ? '' : '-';\n    return name + sep + suffix;\n}\nfunction nextTick(fn) {\n    if (typeof Promise !== 'undefined') {\n        Promise.resolve().then(fn);\n    }\n    else {\n        requestAnimationFrame(fn);\n    }\n}\n\n/**\n * Creates Endorphin component and mounts it into given `options.target` container\n */\nfunction endorphin(name, definition, options = {}) {\n    const component = createComponent(name, definition, options.target);\n    if (options.store) {\n        component.store = options.store;\n    }\n    if (options.target && !options.detached) {\n        options.target.appendChild(component);\n    }\n    mountComponent(component, options.props);\n    return component;\n}\n/**\n * Safe property getter\n * @param {*} ctx\n * @param {*} ...args\n * @returns {*}\n */\nfunction get(ctx) {\n    const hasMap = typeof Map !== 'undefined';\n    for (let i = 1, il = arguments.length, arg; ctx != null && i < il; i++) {\n        arg = arguments[i];\n        if (hasMap && ctx instanceof Map) {\n            ctx = ctx.get(arg);\n        }\n        else {\n            ctx = ctx[arg];\n        }\n    }\n    return ctx;\n}\n/**\n * Invokes `methodName` of `ctx` object with given args\n */\nfunction call(ctx, methodName, args) {\n    const method = ctx != null && ctx[methodName];\n    if (typeof method === 'function') {\n        return args ? method.apply(ctx, args) : method.call(ctx);\n    }\n}\n/**\n * Filter items from given collection that matches `fn` criteria and returns\n * matched items\n */\nfunction filter(collection, fn) {\n    const result = [];\n    if (collection && collection.forEach) {\n        collection.forEach((value, key) => {\n            if (fn(value, key)) {\n                result.push(value);\n            }\n        });\n    }\n    return result;\n}\n/**\n * Finds first item in given `collection` that matches truth test of `fn`\n */\nfunction find(collection, fn) {\n    if (Array.isArray(collection)) {\n        // Fast path: find item in array\n        for (let i = 0, item; i < collection.length; i++) {\n            item = collection[i];\n            if (fn(item, i)) {\n                return item;\n            }\n        }\n    }\n    else if (collection && collection.forEach) {\n        // Iterate over collection\n        let found = false;\n        let result = null;\n        collection.forEach((value, key) => {\n            if (!found && fn(value, key)) {\n                found = true;\n                result = value;\n            }\n        });\n        return result;\n    }\n}\n\nexport default endorphin;\nexport { Store, addClass, addClassIf, addEvent, addPendingClass, addPendingClassIf, animate, appendChild, assign, attributeSet, call, classNames, composeTween, createAnimation, createComponent, createInjector, createScope, createSlot, cssAnimate, detachPendingEvents, disposeBlock, domInsert, domRemove, elem, elemNS, elemNSWithText, elemWithText, emptyBlockContent, enterScope, exitScope, filter, finalizeAttributes, finalizeAttributesNS, finalizePendingEvents, finalizePendingRefs, find, get, getPartial, getProp, getScope, getSlotContext, getState, getVar, injectBlock, insert, isolateElement, mountBlock, mountComponent, mountInnerHTML, mountIterator, mountKeyIterator, mountPartial, mountSlot, move, notifySlotUpdate, obj, pendingEvents, prepareScope, propsSet, removeEvent, removeRef, renderComponent, safeEventListener, scheduleRender, setAttribute, setAttributeExpression, setAttributeExpressionNS, setAttributeNS, setClass, setPendingAttribute, setPendingAttributeNS, setPendingEvent, setPendingRef, setRef, setScope, setVar, stopAnimation, subscribeStore, text, toggleClassIf, tweenAnimate, unmountBlock, unmountComponent, unmountInnerHTML, unmountIterator, unmountKeyIterator, unmountPartial, unmountSlot, updateAttributeExpression, updateAttributeExpressionNS, updateBlock, updateComponent, updateDefaultSlot, updateIncomingSlot, updateInnerHTML, updateIterator, updateKeyIterator, updatePartial, updateText };\n//# sourceMappingURL=runtime.es.js.map\n","const schema = {\n  \"author\": \"TamTam Team\",\n  \"colors\": {\n    \"accent\": \"#697CFF\",\n    \"accentText\": \"#FFFFFF\",\n    \"background\": \"#262626\",\n    \"bubbleBorder\": \"#FFFFFF\",\n    \"bubbleBorderHighLight\": \"#6988E0\",\n    \"bubbleClickableBackground\": \"#2D2D2D\",\n    \"bubbleControlBackground\": \"#626262\",\n    \"bubbleControlsText\": \"#FFFFFF\",\n    \"bubbleDecoratorBackground\": \"#232323\",\n    \"bubbleDecoratorText\": \"#FFFFFF\",\n    \"bubbleOuterBorder\": \"#000000\",\n    \"bubbleSecondaryText\": \"#848484\",\n    \"buttonTint\": \"#FFFFFF\",\n    \"chatBackground\": \"#1C1C1C\",\n    \"destructive\": \"#FF3F3F\",\n    \"fileBadgeBackground\": \"#FBC03D\",\n    \"highlightBackground\": \"#2D2D2D\",\n    \"incomingBubbleBackground\": \"#262626\",\n    \"incomingBubbleBackgroundHighlighted\": \"#2D2D2D\",\n    \"outgoingBubbleBackground\": \"#262626\",\n    \"outgoingBubbleBackgroundHighlighted\": \"#2D2D2D\",\n    \"primaryText\": \"#FFFFFF\",\n    \"profileBackground\": \"#1C1C1C\",\n    \"secondaryBackground\": \"#1C1C1C\",\n    \"secondaryButton\": \"#2D2D2D\",\n    \"secondaryText\": \"#AAAAAA\",\n    \"separatorBackground\": \"#333333\",\n    \"statusBarBackground\": \"#2D2D2D\",\n    \"switchThumb\": \"#848484\",\n    \"switchThumbChecked\": \"#E4E4E4\",\n    \"switchTrack\": \"#444444\",\n    \"switchTrackChecked\": \"#848484\",\n    \"switchTint\": \"#626262\",\n    \"tertiaryText\": \"#AAAAAA\",\n    \"toolBarBackground\": \"#262626\",\n    \"unreadBackground\": \"#28972B\",\n    \"unreadBackgroundMuted\": \"#848484\",\n    \"unreadText\": \"#FFFFFF\"\n  },\n  \"night\": true,\n  \"title\": \"TamTam Dark Contrast\",\n  \"version\": 1\n}\n\nconst cssToProperty = {\n  background: ['--c-bg', '--ui-titlebar-bg', '--c-aside-bg', '--c-bubble-search-bg', '--c-input'],\n  chatBackground: ['--c-chat-bg', '--c-chat-bg-default'],\n  highlightBackground: ['--c-active', '--c-active-chat-item', '--c-btn-active', '--c-global-search'],\n  separatorBackground: '--c-delimiter',\n  secondaryBackground: '--c-delimiter-fat',\n  drawer: '--c-drawer',\n  accent: '--c-highlight',\n  destructive: '--c-error',\n  favorite: '--c-favorite',\n  primaryText: ['--c-text', '--c-link-hover', '--c-btn-text', '--c-msg-text'],\n  secondaryText: ['--c-text-sub', '--c-link', '--c-msg-mine-sub', '--c-aside-text'],\n  incomingBubbleBackground: '--c-msg',\n  outgoingBubbleBackground: '--c-msg-mine',\n  unreadBackground: '--c-bubble-bg',\n  unreadBackgroundMuted: '--c-bubble-muted-bg',\n  unreadText: '--c-bubble-text',\n  secondaryButton: '--c-btn',\n  tertiaryText: ['--c-btn-tertiary', '--c-input-border'],\n  accentText: '--c-btn-tertiary-text',\n}\n\nexport const events = {\n  change(component, event) {\n    applyColor(event.target.name, event.target.value);\n  }\n};\n\nexport function state() {\n  return {\n    colorKeys: Object.keys(cssToProperty),\n    schema\n  };\n}\n\nexport function onChangeColor(colorName, component) {\n  // console.log(colorName, getComputedStyle(document.body).getPropertyValue(cssToProperty[colorName]));\n  // console.log(schema.colors[colorName], colorName);\n}\n\nexport function didMount(component) {\n  component.state.colorKeys.forEach(colorName => {\n    const color = schema.colors[colorName];\n\n    applyColor(colorName, color);\n  });\n}\n\nfunction toArray(item) {\n  return [].concat(item);\n}\n\nfunction applyColor(colorName, color) {\n  const cssVars = toArray(cssToProperty[colorName]);\n\n  cssVars.forEach(cssVar => {\n    document.documentElement.style.setProperty(cssVar, color);\n  });\n}","<link rel=\"stylesheet\" href=\"./colors.css\"/>\n<script src=\"./colors.js\"/>\n\n<template>\n\t<div class=\"circle-container\">\n\t\t<e:for-each select={#colorKeys}>\n\t\t\t<div class=\"circle\">\n\t\t\t\t<input type=\"color\" value={#schema.colors[@value]} name={@value}/>\n\t\t\t</div>\n\t\t</e:for-each>\n\t</div>\n</template>","import endorphin from 'endorphin';\nimport * as Colors from './colors.html';\n\nendorphin('colors', Colors, {\n\ttarget: document.getElementById('colors')\n});"],"names":["#colorKeys","#schema","@value"],"mappings":"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"}